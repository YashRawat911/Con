'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _marked = /*#__PURE__*/regeneratorRuntime.mark(cycle);

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var name = 'page-label-generator',
    version = '1.1.0';
var labelGen = {
  /**
   * Generator for page labels.
   *
   * A note about bracketing: Only one of `bracket`, `twoUpBracketLeftOnly`,
   * `twoUpBracketRightOnly` can be set, and `bracketEvens` and `bracketOdds`
   * can only be set if none of the first three options are set. The following
   * is an example of the difference between each option (this is also shown in
   * greater detail in the README).
   *
   * `bracket` wraps the whole string in brackets: [f. 1a], [f. 1b], [f 2a], ...
   *
   * `bracketEvens` and `bracketOdds` wraps just the evens/odds in brackets,
   *  and doesn't make much sense for twoUp configs: [p. 1], p. 2, [p. 3], ...
   *
   *  `twoUpBracketLeftOnly` and `twoUpBracketRightOnly` brackets just the
   * value on the right or left side of the separator: f. 2a/[1b], f. 3a/[2b],
   * f. 4a/[3b], ...
   *
   * @param {(number|string)} [start=1] - A number or a roman numeral.
   * @param {string} [method=paginate] - If set to "foliate" each value is
   * @param {string} [frontLabel=""]  - The label for the front of a leaf.
   * @param {string} [backLabel=""] - The label for the back of a leaf.
   *   yielded twice.
   * @param {string} [startWith=front] - If set to "back" and method=foliate,
   *   the first value only yielded once.
   * @param {string} [unitLabel=""] - A label for the unit, like "p. " or "f. ".
   * @param {boolean} [bracket=false] - If true add brackets ('[]') around the
   *   label.
   * @param {boolean} [bracketEvens=false] - If true add brackets ('[]') around
   *   the even numbered pages.
   * @param {boolean} [bracketOdds=false] - If true add brackets ('[]') around
   *   the odd numbered pages.
   * @param {boolean} [twoUp=false] - If true, yield two values as a time
   * @param {string} [twoUpSeparator="/"] - If twoUp, separate the values
   *   with this string.
   * @param {string} [twoUpDir="ltr"] - ltr or rtl. If twoUp and "rtl", the
   *   the larger value with be on the left of the separator
   * @param {string} [twoUpBracketLeftOnly=false] - If twoUp and true, bracket
   *   the value to the left of the separator only.
   * @param {string} [twoUpBracketRightOnly=false] - If twoUp and true, bracket
   *   the value to the right of the separator only.
   */
  pageLabelGenerator: /*#__PURE__*/regeneratorRuntime.mark(function pageLabelGenerator() {
    var _ref,
        _ref$start,
        start,
        _ref$method,
        method,
        _ref$frontLabel,
        frontLabel,
        _ref$backLabel,
        backLabel,
        _ref$startWith,
        startWith,
        _ref$unitLabel,
        unitLabel,
        _ref$bracket,
        bracket,
        _ref$bracketOdds,
        bracketOdds,
        _ref$bracketEvens,
        bracketEvens,
        _ref$twoUp,
        twoUp,
        _ref$twoUpSeparator,
        twoUpSeparator,
        _ref$twoUpDir,
        twoUpDir,
        _ref$twoUpBracketLeft,
        twoUpBracketLeftOnly,
        _ref$twoUpBracketRigh,
        twoUpBracketRightOnly,
        numberer,
        frontBackLabeler,
        bracketVals,
        _bracketVals,
        bracketOpen,
        bracketClose,
        bracketLeftOpen,
        bracketLeftClose,
        bracketRightOpen,
        bracketRightClose,
        evenOddBracketsAllowed,
        open,
        close,
        _numberer$next$value,
        num1,
        c,
        side1,
        page1,
        eoBracketL,
        eoBracketR,
        _this$evenOddBracket,
        _this$evenOddBracket2,
        _numberer$next$value2,
        num2,
        _c,
        side2,
        sep,
        page2,
        _args = arguments;

    return regeneratorRuntime.wrap(function pageLabelGenerator$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, _ref$start = _ref.start, start = _ref$start === void 0 ? 1 : _ref$start, _ref$method = _ref.method, method = _ref$method === void 0 ? 'paginate' : _ref$method, _ref$frontLabel = _ref.frontLabel, frontLabel = _ref$frontLabel === void 0 ? '' : _ref$frontLabel, _ref$backLabel = _ref.backLabel, backLabel = _ref$backLabel === void 0 ? '' : _ref$backLabel, _ref$startWith = _ref.startWith, startWith = _ref$startWith === void 0 ? 'front' : _ref$startWith, _ref$unitLabel = _ref.unitLabel, unitLabel = _ref$unitLabel === void 0 ? '' : _ref$unitLabel, _ref$bracket = _ref.bracket, bracket = _ref$bracket === void 0 ? false : _ref$bracket, _ref$bracketOdds = _ref.bracketOdds, bracketOdds = _ref$bracketOdds === void 0 ? false : _ref$bracketOdds, _ref$bracketEvens = _ref.bracketEvens, bracketEvens = _ref$bracketEvens === void 0 ? false : _ref$bracketEvens, _ref$twoUp = _ref.twoUp, twoUp = _ref$twoUp === void 0 ? false : _ref$twoUp, _ref$twoUpSeparator = _ref.twoUpSeparator, twoUpSeparator = _ref$twoUpSeparator === void 0 ? '/' : _ref$twoUpSeparator, _ref$twoUpDir = _ref.twoUpDir, twoUpDir = _ref$twoUpDir === void 0 ? 'ltr' : _ref$twoUpDir, _ref$twoUpBracketLeft = _ref.twoUpBracketLeftOnly, twoUpBracketLeftOnly = _ref$twoUpBracketLeft === void 0 ? false : _ref$twoUpBracketLeft, _ref$twoUpBracketRigh = _ref.twoUpBracketRightOnly, twoUpBracketRightOnly = _ref$twoUpBracketRigh === void 0 ? false : _ref$twoUpBracketRigh;
            numberer = this.pageNumberGenerator(_args[0]), frontBackLabeler = this.frontBackLabeler(_args[0]), bracketVals = this.bracketLogic(_args[0]), _bracketVals = _slicedToArray(bracketVals, 6), bracketOpen = _bracketVals[0], bracketClose = _bracketVals[1], bracketLeftOpen = _bracketVals[2], bracketLeftClose = _bracketVals[3], bracketRightOpen = _bracketVals[4], bracketRightClose = _bracketVals[5], evenOddBracketsAllowed = bracketVals.every(function (v) {
              return v == '';
            }), open = "".concat(bracketOpen).concat(bracketLeftOpen), close = "".concat(bracketRightClose).concat(bracketClose);

          case 2:
            if (!true) {
              _context.next = 20;
              break;
            }

            _numberer$next$value = _slicedToArray(numberer.next().value, 2), num1 = _numberer$next$value[0], c = _numberer$next$value[1], side1 = frontBackLabeler.next().value, page1 = "".concat(num1).concat(side1), eoBracketL = '', eoBracketR = '';

            if (evenOddBracketsAllowed) {
              _this$evenOddBracket = this.evenOddBracket(c, bracketEvens, bracketOdds);
              _this$evenOddBracket2 = _slicedToArray(_this$evenOddBracket, 2);
              eoBracketL = _this$evenOddBracket2[0];
              eoBracketR = _this$evenOddBracket2[1];
            }

            if (twoUp) {
              _context.next = 10;
              break;
            }

            _context.next = 8;
            return "".concat(open).concat(eoBracketL).concat(unitLabel).concat(page1).concat(eoBracketR).concat(close);

          case 8:
            _context.next = 18;
            break;

          case 10:
            _numberer$next$value2 = _slicedToArray(numberer.next().value, 2), num2 = _numberer$next$value2[0], _c = _numberer$next$value2[1], side2 = frontBackLabeler.next().value, sep = "".concat(bracketLeftClose).concat(twoUpSeparator).concat(bracketRightOpen), page2 = "".concat(num2).concat(side2);

            if (!(twoUpDir == 'rtl')) {
              _context.next = 16;
              break;
            }

            _context.next = 14;
            return "".concat(open).concat(unitLabel).concat(page2).concat(sep).concat(page1).concat(close);

          case 14:
            _context.next = 18;
            break;

          case 16:
            _context.next = 18;
            return "".concat(open).concat(unitLabel).concat(page1).concat(sep).concat(page2).concat(close);

          case 18:
            _context.next = 2;
            break;

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, pageLabelGenerator, this);
  }),
  evenOddBracket: function evenOddBracket(numInt, doEvens, doOdds) {
    if (doOdds && numInt % 2 == 1 || doEvens && numInt % 2 == 0) {
      return ['[', ']'];
    } else {
      return ['', ''];
    }
  },

  /**
   * Generator for page numbers.
   * @param {(number|string)} [start=1] - A number or a roman numeral.
   * @param {string} [method=paginate] - If set to "foliate" each value is
   *   yielded twice.
   * @param {string} [startWith=front] - If set to "back" and method=foliate,
   *   the first value only yielded once.
   * @yields {[(string, number]} - A two member array, the first item being
   *   the value for use in the label, and the second being that value
   *   represented as an integer.
   */
  pageNumberGenerator: /*#__PURE__*/regeneratorRuntime.mark(function pageNumberGenerator() {
    var _ref2,
        _ref2$start,
        start,
        _ref2$method,
        method,
        _ref2$startWith,
        startWith,
        roman,
        capital,
        counter,
        changeFolio,
        val,
        _args2 = arguments;

    return regeneratorRuntime.wrap(function pageNumberGenerator$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref2 = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, _ref2$start = _ref2.start, start = _ref2$start === void 0 ? 1 : _ref2$start, _ref2$method = _ref2.method, method = _ref2$method === void 0 ? 'paginate' : _ref2$method, _ref2$startWith = _ref2.startWith, startWith = _ref2$startWith === void 0 ? 'front' : _ref2$startWith;
            roman = false, capital = false, counter = start, changeFolio = false;

            if (!isInt(start)) {
              roman = true;
              capital = start == start.toUpperCase();
              start.toLowerCase();
              counter = this.deromanize(start); // TODO: need an error if deromanize fails
            }

            if (startWith == 'back') changeFolio = !changeFolio;

          case 4:
            if (!true) {
              _context2.next = 17;
              break;
            }

            if (!roman) {
              _context2.next = 12;
              break;
            }

            val = this.romanize(counter);
            if (capital) val = val.toUpperCase();
            _context2.next = 10;
            return [val, counter];

          case 10:
            _context2.next = 14;
            break;

          case 12:
            _context2.next = 14;
            return [String(counter), counter];

          case 14:
            if (method == 'foliate') {
              if (changeFolio) counter++;
              changeFolio = !changeFolio;
            } else counter++;

            _context2.next = 4;
            break;

          case 17:
          case "end":
            return _context2.stop();
        }
      }
    }, pageNumberGenerator, this);
  }),

  /**
   * Generator for front and back of leaf labels.
   * @param {string} [frontLabel=""]  - The label for the front of a leaf.
   * @param {string} [backLabel=""] - The label for the back of a leaf.
   * @param {string} [startWith=front] - If set to "back", backLabel is yielded first.
   */
  frontBackLabeler: /*#__PURE__*/regeneratorRuntime.mark(function frontBackLabeler() {
    var _ref3,
        _ref3$frontLabel,
        frontLabel,
        _ref3$backLabel,
        backLabel,
        _ref3$startWith,
        startWith,
        labels,
        labeler,
        _args3 = arguments;

    return regeneratorRuntime.wrap(function frontBackLabeler$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _ref3 = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {}, _ref3$frontLabel = _ref3.frontLabel, frontLabel = _ref3$frontLabel === void 0 ? '' : _ref3$frontLabel, _ref3$backLabel = _ref3.backLabel, backLabel = _ref3$backLabel === void 0 ? '' : _ref3$backLabel, _ref3$startWith = _ref3.startWith, startWith = _ref3$startWith === void 0 ? 'front' : _ref3$startWith;
            labels = [frontLabel, backLabel];
            if (startWith == 'back') labels.reverse();
            labeler = cycle(labels);

          case 4:
            if (!true) {
              _context3.next = 9;
              break;
            }

            _context3.next = 7;
            return labeler.next().value;

          case 7:
            _context3.next = 4;
            break;

          case 9:
          case "end":
            return _context3.stop();
        }
      }
    }, frontBackLabeler);
  }),

  /**
   * Examine options to detemine what brackets to include. Only one of
   * `bracket`, `twoUpBracketLeftOnly`, `twoUpBracketRightOnly` can be set.
   * This function enforces that (interfaces should enforce it as well) and
   * returns the  appropriate strings for use in templates. If more than one
   * option is true, all brackets return will be empty strings (`''`).
   * @param {boolean} [bracket=false] - If true add brackets ('[]') around the
   *   entire label.
   * @param {string} [twoUpBracketLeftOnly=false] - If twoUp and true, bracket
   *   the value to the left of the separator only.
   * @param {string} [twoUpBracketRightOnly=false] - If twoUp and true, bracket
   *   the value to the right of the separator only.
   */
  bracketLogic: function bracketLogic() {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref4$bracket = _ref4.bracket,
        bracket = _ref4$bracket === void 0 ? false : _ref4$bracket,
        _ref4$twoUpBracketLef = _ref4.twoUpBracketLeftOnly,
        twoUpBracketLeftOnly = _ref4$twoUpBracketLef === void 0 ? false : _ref4$twoUpBracketLef,
        _ref4$twoUpBracketRig = _ref4.twoUpBracketRightOnly,
        twoUpBracketRightOnly = _ref4$twoUpBracketRig === void 0 ? false : _ref4$twoUpBracketRig;

    var bracketOpen = '',
        bracketClose = '',
        bracketLeftOpen = '',
        bracketLeftClose = '',
        bracketRightOpen = '',
        bracketRightClose = '';

    if (bracket && !(twoUpBracketLeftOnly || twoUpBracketRightOnly)) {
      bracketOpen = '[';
      bracketClose = ']';
    } else if (twoUpBracketLeftOnly && !(bracket || twoUpBracketRightOnly)) {
      bracketLeftOpen = '[';
      bracketLeftClose = ']';
    } else if (twoUpBracketRightOnly && !(bracket || twoUpBracketLeftOnly)) {
      bracketRightOpen = '[';
      bracketRightClose = ']';
    }

    return [bracketOpen, bracketClose, bracketLeftOpen, bracketLeftClose, bracketRightOpen, bracketRightClose];
  },

  /**
   * Roman numeral helpers lifted from
   * http://blog.stevenlevithan.com/archives/javascript-roman-numeral-converter
   * with only slight modifications
   */
  romanize: function romanize(num) {
    if (!+num) return false;
    var digits = String(+num).split(''),
        key = ['', 'c', 'cc', 'ccc', 'cd', 'd', 'dc', 'dcc', 'dccc', 'cm', '', 'x', 'xx', 'xxx', 'xl', 'l', 'lx', 'lxx', 'lxxx', 'xc', '', 'i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix'],
        roman = '',
        i = 3;

    while (i--) {
      roman = (key[+digits.pop() + i * 10] || '') + roman;
    }

    return Array(+digits.join('') + 1).join('m') + roman;
  },

  /**
   * Roman numeral helpers lifted from
   * http://blog.stevenlevithan.com/archives/javascript-roman-numeral-converter
   * with only slight modifications
   */
  deromanize: function deromanize(str) {
    str = str.toLowerCase();
    var validator = /^m*(?:d?c{0,3}|c[md])(?:l?x{0,3}|x[cl])(?:v?i{0,3}|i[xv])$/,
        token = /[mdlv]|c[md]?|x[cl]?|i[xv]?/g,
        key = {
      m: 1000,
      cm: 900,
      d: 500,
      cd: 400,
      c: 100,
      xc: 90,
      l: 50,
      xl: 40,
      x: 10,
      ix: 9,
      v: 5,
      iv: 4,
      i: 1
    },
        num = 0,
        m;
    if (!(str && validator.test(str))) return false; // eslint-disable-next-line no-cond-assign

    while (m = token.exec(str)) {
      num += key[m[0]];
    }

    return num;
  }
};
/**
 * Generator to endlessly iterate through the members of an array, starting over
 * at the beginning when members run out.
 * @param {*[]} arr - An array of anything.
 */

function cycle(arr) {
  var nxt;
  return regeneratorRuntime.wrap(function cycle$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          if (!true) {
            _context4.next = 7;
            break;
          }

          nxt = arr.shift();
          arr.push(nxt);
          _context4.next = 5;
          return nxt;

        case 5:
          _context4.next = 0;
          break;

        case 7:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked);
}

function isInt(n) {
  return Number(n) === n && n % 1 === 0;
}

var _default = labelGen;
exports["default"] = _default;